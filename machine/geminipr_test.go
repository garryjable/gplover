// Copyright (c) 2025 Garrett JenningsStrokePacket.
// This File is part of sten. Sten is free software under GPLv3 .
// See LICENSE.txt for details.

package machine

import (
	"testing"
	"time"

	"github.com/tarm/serial"
)

var expectedGeminiBits = map[string]StrokePacket{
	"Fn":   {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#1":   {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#2":   {0x90, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#3":   {0x88, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#4":   {0x84, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#5":   {0x82, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#6":   {0x81, 0x00, 0x00, 0x00, 0x00, 0x00},
	"S1-":  {0x80, 0x40, 0x00, 0x00, 0x00, 0x00},
	"S2-":  {0x80, 0x20, 0x00, 0x00, 0x00, 0x00},
	"T-":   {0x80, 0x10, 0x00, 0x00, 0x00, 0x00},
	"K-":   {0x80, 0x08, 0x00, 0x00, 0x00, 0x00},
	"P-":   {0x80, 0x04, 0x00, 0x00, 0x00, 0x00},
	"W-":   {0x80, 0x02, 0x00, 0x00, 0x00, 0x00},
	"H-":   {0x80, 0x01, 0x00, 0x00, 0x00, 0x00},
	"R-":   {0x80, 0x00, 0x40, 0x00, 0x00, 0x00},
	"A-":   {0x80, 0x00, 0x20, 0x00, 0x00, 0x00},
	"O-":   {0x80, 0x00, 0x10, 0x00, 0x00, 0x00},
	"*1":   {0x80, 0x00, 0x08, 0x00, 0x00, 0x00},
	"*2":   {0x80, 0x00, 0x04, 0x00, 0x00, 0x00},
	"res1": {0x80, 0x00, 0x02, 0x00, 0x00, 0x00},
	"res2": {0x80, 0x00, 0x01, 0x00, 0x00, 0x00},
	"pwr":  {0x80, 0x00, 0x00, 0x40, 0x00, 0x00},
	"*3":   {0x80, 0x00, 0x00, 0x20, 0x00, 0x00},
	"*4":   {0x80, 0x00, 0x00, 0x10, 0x00, 0x00},
	"-E":   {0x80, 0x00, 0x00, 0x08, 0x00, 0x00},
	"-U":   {0x80, 0x00, 0x00, 0x04, 0x00, 0x00},
	"-F":   {0x80, 0x00, 0x00, 0x02, 0x00, 0x00},
	"-R":   {0x80, 0x00, 0x00, 0x01, 0x00, 0x00},
	"-P":   {0x80, 0x00, 0x00, 0x00, 0x40, 0x00},
	"-B":   {0x80, 0x00, 0x00, 0x00, 0x20, 0x00},
	"-L":   {0x80, 0x00, 0x00, 0x00, 0x10, 0x00},
	"-G":   {0x80, 0x00, 0x00, 0x00, 0x08, 0x00},
	"-T":   {0x80, 0x00, 0x00, 0x00, 0x04, 0x00},
	"-S":   {0x80, 0x00, 0x00, 0x00, 0x02, 0x00},
	"-D":   {0x80, 0x00, 0x00, 0x00, 0x01, 0x00},
	"#7":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x40},
	"#8":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x20},
	"#9":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x10},
	"#A":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x08},
	"#B":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x04},
	"#C":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x02},
	"-Z":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x01},
}

func TestProcessPacket_ValidChordPacket(t *testing.T) {

	packet := StrokePacket{0x80, 0x18, 0x30, 0x00, 0x51, 0x00} // T- K- A- O- -P -L -D Chord spells "doomed"

	expected := []string{"T-", "K-", "A-", "O-", "-P", "-L", "-D"}

	stroke, err := packet.toStroke()
	if err != nil {
		t.Fatalf("packet failed to parse")
	}
	if len(stroke) == 0 {
		t.Errorf("expected stroke, got %v", stroke)
	}

	for i, key := range expected {
		if stroke[i] != key {
			t.Errorf("expected %s as %d key, got %v", key, i, stroke[0])
		}
	}
}

func TestGeminiPacketEncoding(t *testing.T) {
	for expected, packet := range expectedGeminiBits {
		stroke := packet.toStroke()
		if stroke == nil {
			t.Fatalf("packet failed to parse")
		}
		if len(stroke) == 0 || stroke[0] != expected {
			t.Errorf("expected T-, got %v", stroke)
		}
	}
}

func TestProcessPacket_InvalidFirstByte(t *testing.T) {
	packet := StrokePacket{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	stroke := packet.toStroke()
	if stroke != nil {
		t.Errorf("Packet parsed incorrectly")
	}
}

func TestProcessPacket_InvalidOtherByte(t *testing.T) {
	packet := StrokePacket{0x80, 0x80, 0x00, 0x00, 0x00, 0x00}
	stroke := packet.toStroke()
	if stroke != nil {
		t.Errorf("Packet parsed incorrectly")
	}
}

func TestStartStopCapture(t *testing.T) {
	m := NewGeminiPrMachine("/dev/null", 9600, nil)
	err := m.StartCapture()
	if err == nil {
		t.Error("expected failure on opening /dev/null as serial port")
	}
}

func TestNewGeminiPrMachineDefaults(t *testing.T) {
	m := NewGeminiPrMachine("test", 1234, nil)
	if m == nil {
		t.Fatal("expected machine instance, got nil")
	}
	if m.baudRate != 1234 || m.portName != "test" {
		t.Errorf("unexpected config: %+v", m)
	}
	if m.callback != nil {
		t.Errorf("expected nil callback")
	}
}

func TestReadLoopStops(t *testing.T) {
	m := NewGeminiPrMachine("", 0, nil)
	fakePort := &serial.Port{}
	m.port = fakePort
	m.StartCapture()
	m.StopCapture()
	m.readLoop() // should return quickly
}

type MockSerialPort struct {
	readDelay time.Duration
	error     error
}

func (m *MockSerialPort) Read(p []byte) (int, error) {
	time.Sleep(m.readDelay)
	return 0, m.error
}

func (m *MockSerialPort) Close() error {
	return nil
}
